
### Brute Force Approach
- Go through each element at index i, and compare it with every element from index 'i+1' to n (where n = size of array).
```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        for i in range(0, len(nums)):
            for j in range(i+1, len(nums)):
                if nums[i] == nums[j]:
                    return True
        return False
```

- This solution is very slow. As it's complexity is O(n<sup>2</sup>).
- This solution is <ins>not accepted</ins> by Leetcode.

### Sort and Search
- Sort the array first.
- Then compare adjacent elements(i and i+1) of the array in just one pass (one for loop).
- Complexity --> O(n.logn)

### Using Python Sets
```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        # unique is a hash set
        unique = set()
        for n in nums:
            if n in unique:
                return True
            unique.add(n)
        return False
```
- This is the fastest solution of the 3 we have discussed.
- Here we add elements from the array into a Set (acts as a Hash Map as a set has only unique values).
- Before adding elements to the Set we verify if that element is already in the Set. If so, then we have found our duplicate.
- Complexity --> O(n)
